<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            color: #D4AF37; /* Metallic Gold */
            text-align: center;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 24px; }
        p.subtitle { color: #888; font-size: 12px; margin-top: 5px; }

        .controls {
            pointer-events: auto;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .btn {
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 12px 24px; /* Larger touch target */
            cursor: pointer;
            text-transform: uppercase;
            font-size: 14px; /* Larger font */
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border-radius: 4px; /* Soft edges */
            margin-bottom: 10px;
        }

        .btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }

        /* Hidden video element for MediaPipe */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px; 
            height: 1px;
            opacity: 0;
            z-index: -1;
        }

        /* Hand Tracking visualizer (small preview) */
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px; /* Smaller on mobile */
            height: 90px;
            background: #000;
            border: 1px solid #333;
            z-index: 20;
            transform: scaleX(-1); /* Mirror effect */
            border-radius: 8px;
            opacity: 0.7;
        }

        #gesture-hint {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: white;
            font-size: 14px;
            line-height: 1.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            max-width: 60%; /* Prevent overlap */
        }
        
        @media (max-width: 600px) {
            h1 { font-size: 18px; letter-spacing: 2px; }
            #gesture-hint { font-size: 12px; bottom: 80px; left: 20px; max-width: 80%; }
            #camera-preview { bottom: auto; top: 20px; right: 20px; width: 80px; height: 60px; }
        }

        .highlight { color: #ff4d4d; font-weight: bold; }

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #050505;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #D4AF37;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            border-top-color: #D4AF37;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Cursor follower for hand */
        #hand-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            display: none;
            box-shadow: 0 0 10px #fff;
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">åˆå§‹åŒ–ç¥ç»ç½‘ç»œä¸æ¸²æŸ“å¼•æ“...</div>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <div class="header">
            <h1>Chroma Christmas</h1>
            <p class="subtitle">GESTURE INTERACTIVE EXPERIENCE</p>
        </div>
        
        <div class="controls">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
            <button class="btn" onclick="document.getElementById('photo-upload').click()">+ ä¸Šä¼ ç…§ç‰‡ (æ‰“é€ ç…§ç‰‡äº‘)</button>
            <button class="btn" id="debug-btn">è°ƒè¯•è§†å›¾: å…³</button>
        </div>

        <div id="gesture-hint">
            çŠ¶æ€: <span id="status-text">ç­‰å¾…æ‰‹åŠ¿...</span><br>
            âœŠ <b>æ¡æ‹³</b> - èšåˆåœ£è¯æ ‘<br>
            ğŸ– <b>å¼ æ‰‹</b> - ç‚¸å¼€ç²’å­äº‘<br>
            ğŸ‘Œ <b>æåˆ</b> - æŠ“å–ç…§ç‰‡è¯¦æƒ…<br>
            ğŸ‘‹ <b>ç§»åŠ¨</b> - æ—‹è½¬è§†è§’
        </div>
    </div>

    <div id="hand-cursor"></div>
    <video id="input-video" playsinline></video>
    <canvas id="camera-preview"></canvas>
    <div id="canvas-container"></div>

    <!-- Libraries -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        /**
         * CONFIGURATION & CONSTANTS
         */
        // Detect Mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const CONFIG = {
            colors: {
                green: 0x2F4F4F, // Matte Green
                gold: 0xFFD700,  // Metallic Gold
                red: 0x8B0000,   // Christmas Red
                light: 0xFFF8E7  // Warm Light
            },
            // Optimize for mobile: Reduce particles
            particleCount: isMobile ? 150 : 400,
            treeHeight: 25,
            treeRadius: 10,
            scatterRadius: 30
        };

        let userPhotos = [];
        let state = 'TREE'; // 'TREE', 'SCATTERED', 'ZOOM'
        let previousState = 'TREE';
        
        // Hand tracking variables
        let handX = 0, handY = 0; // Normalized 0-1
        let isHandPresent = false;
        let pinchDistance = 1;

        /**
         * THREE.JS SETUP
         */
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // Post Processing (Bloom)
        const renderScene = new THREE.RenderPass(scene, camera);
        // Reduce resolution of bloom on mobile for performance
        const bloomResolution = isMobile ? new THREE.Vector2(window.innerWidth/2, window.innerHeight/2) : new THREE.Vector2(window.innerWidth, window.innerHeight);
        const bloomPass = new THREE.UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // Cinematic glow intensity
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        /**
         * MATERIALS
         */
        const matGreen = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.green,
            roughness: 0.9,
            metalness: 0.1
        });

        const matGold = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.gold,
            roughness: 0.2,
            metalness: 1.0,
            emissive: 0x332200
        });

        const matRed = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.red,
            roughness: 0.4,
            metalness: 0.3
        });

        /**
         * OBJECT GENERATION
         */
        const objects = [];
        const geometries = [
            new THREE.SphereGeometry(0.4, 32, 32),
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.IcosahedronGeometry(0.5, 0)
        ];

        // Group to hold everything for easy rotation
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // Helper to load textures
        const textureLoader = new THREE.TextureLoader();
        const defaultPhotoTexture = new THREE.CanvasTexture(createPlaceholderCanvas());

        function createPlaceholderCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0,0,256,256);
            ctx.strokeStyle = '#D4AF37';
            ctx.lineWidth = 10;
            ctx.strokeRect(10,10,236,236);
            ctx.fillStyle = '#D4AF37';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PHOTO', 128, 140);
            return canvas;
        }

        // Initialize Particles
        function initParticles() {
            // Cleanup existing
            objects.forEach(obj => treeGroup.remove(obj));
            objects.length = 0;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                
                // Decide type: Photo (Plane) or Decoration (Geom)
                // If we have user photos, use them more often, otherwise 10% chance of default photo
                const isPhoto = Math.random() < 0.15; 

                if (isPhoto) {
                    const geometry = new THREE.PlaneGeometry(1.5, 1.5); // Photo size
                    let material;
                    
                    if (userPhotos.length > 0) {
                        const tex = userPhotos[i % userPhotos.length];
                        material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                    } else {
                        material = new THREE.MeshBasicMaterial({ map: defaultPhotoTexture, side: THREE.DoubleSide });
                    }
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.isPhoto = true;
                } else {
                    const geomIndex = Math.floor(Math.random() * geometries.length);
                    const matIndex = Math.random();
                    let material = matGreen;
                    if (matIndex > 0.6) material = matGold;
                    else if (matIndex > 0.4) material = matRed;

                    mesh = new THREE.Mesh(geometries[geomIndex], material);
                }

                // Calculate Tree Position (Cone Spiral)
                const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight / 2; // -12.5 to 12.5
                const normalizedY = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight; // 0 to 1 (bottom to top)
                const radiusAtY = CONFIG.treeRadius * (1 - normalizedY); // Cone shape
                const angle = y * 3 + Math.random() * Math.PI * 2; // Spiral
                
                const tx = Math.cos(angle) * radiusAtY;
                const tz = Math.sin(angle) * radiusAtY;
                const ty = y;

                // Store Tree Pos
                mesh.userData.treePos = new THREE.Vector3(tx, ty, tz);
                
                // Store Scatter Pos (Random Cloud)
                mesh.userData.scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.scatterRadius,
                    (Math.random() - 0.5) * CONFIG.scatterRadius,
                    (Math.random() - 0.5) * CONFIG.scatterRadius
                );

                // Initial State: Tree
                mesh.position.copy(mesh.userData.treePos);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

                objects.push(mesh);
                treeGroup.add(mesh);
            }
        }

        initParticles();

        /**
         * STATE MANAGEMENT & ANIMATION
         */
        
        function updateState(newState) {
            if (state === newState) return;
            previousState = state;
            state = newState;
            
            const statusText = document.getElementById('status-text');

            if (state === 'TREE') {
                statusText.innerHTML = "èšåˆ (åœ£è¯æ ‘æ€)";
                statusText.style.color = "#D4AF37";
                animateToTree();
            } else if (state === 'SCATTERED') {
                statusText.innerHTML = "æ•£å¼€ (æ˜Ÿäº‘æ€)";
                statusText.style.color = "#ff4d4d";
                animateToScatter();
            } else if (state === 'ZOOM') {
                statusText.innerHTML = "èšç„¦ (è¯¦æƒ…æ€)";
                statusText.style.color = "#fff";
                animateToZoom();
            }
        }

        function animateToTree() {
            objects.forEach(obj => {
                gsap.to(obj.position, {
                    x: obj.userData.treePos.x,
                    y: obj.userData.treePos.y,
                    z: obj.userData.treePos.z,
                    duration: 1.5,
                    ease: "power2.inOut"
                });
                gsap.to(obj.scale, { x: 1, y: 1, z: 1, duration: 1 });
                gsap.to(obj.rotation, { 
                    x: Math.random() * Math.PI, 
                    y: Math.random() * Math.PI, 
                    duration: 1.5 
                });
            });
            // Reset Camera Zoom
            gsap.to(camera.position, { z: 40, duration: 1.5 });
        }

        function animateToScatter() {
            objects.forEach(obj => {
                gsap.to(obj.position, {
                    x: obj.userData.scatterPos.x,
                    y: obj.userData.scatterPos.y,
                    z: obj.userData.scatterPos.z,
                    duration: 2,
                    ease: "elastic.out(1, 0.75)"
                });
                gsap.to(obj.scale, { x: 1, y: 1, z: 1, duration: 1 });
            });
            gsap.to(camera.position, { z: 40, duration: 1.5 });
        }

        function animateToZoom() {
            // 1. Scatter background
            if (state !== 'SCATTERED') animateToScatter(); // Ensure scattered first

            // 2. Find a photo to zoom into
            // In a real scenario, we'd use a raycaster based on hand position.
            // Simplified: Find the photo closest to the "center" of the scatter cloud or random
            const photos = objects.filter(o => o.userData.isPhoto);
            if (photos.length === 0) return;

            // Pick a random photo or specific one based on some logic
            const target = photos[Math.floor(Math.random() * photos.length)];

            // Bring target to front center
            gsap.to(target.position, {
                x: 0, y: 0, z: 20, // Close to camera
                duration: 1,
                overwrite: true
            });
            
            // Make it face camera flatly
            gsap.to(target.rotation, { x: 0, y: 0, z: 0, duration: 1 });
            
            // Scale up
            gsap.to(target.scale, { x: 3, y: 3, z: 3, duration: 1 });
        }

        /**
         * TOUCH INTERACTION (Mobile Support)
         */
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchTime = 0;

        window.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) return; // Ignore pinch for now, handled by gesture logic if needed
            // e.preventDefault(); // Prevent scrolling

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            
            const deltaX = (touchX - touchStartX) * 0.01;
            const deltaY = (touchY - touchStartY) * 0.01;

            // Rotate tree based on drag
            treeGroup.rotation.y += deltaX;
            treeGroup.rotation.x += deltaY;

            touchStartX = touchX;
            touchStartY = touchY;
        }, {passive: false});

        window.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchTime < 300) {
                // Double tap logic if needed
            } else {
                // Single tap (if moved very little)
                // Note: Simple tap to toggle state for convenience on mobile
                // Since gesture holding is hard on phone
                // We toggle: Tree -> Scatter -> Tree
                // Zoom is hard to trigger via simple tap without raycast, so let's keep it simple
                if (state === 'TREE') updateState('SCATTERED');
                else if (state === 'SCATTERED') updateState('TREE');
                else if (state === 'ZOOM') updateState('SCATTERED');
            }
            lastTouchTime = now;
        });


        /**
         * MEDIAPIPE HANDS SETUP
         */
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('camera-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const handCursor = document.getElementById('hand-cursor');

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: isMobile ? 0 : 1, // 0 = Lite (Faster for mobile), 1 = Full
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        // Load Camera
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        cameraUtils.start()
            .then(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            })
            .catch(err => {
                console.error("Camera error:", err);
                document.getElementById('loading-text').innerText = "æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚";
            });

        // Gesture Logic
        function onResults(results) {
            // Draw Preview
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(previewCtx, landmarks, {color: '#FF0000', lineWidth: 1});
                }
            }
            previewCtx.restore();

            // Logic
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                handCursor.style.display = 'block';
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Center of Palm (Index 0 is wrist, 9 is middle finger mcp)
                const palmX = landmarks[9].x;
                const palmY = landmarks[9].y;
                
                // Update UI Cursor (Mirror X)
                handX = 1 - palmX; 
                handY = palmY;
                handCursor.style.left = (handX * 100) + 'vw';
                handCursor.style.top = (handY * 100) + 'vh';

                // 2. Count Fingers Up
                // Simple logic: tip y < pip y (for fingers 2,3,4,5). Thumb is x diff.
                let fingersUp = 0;
                // Index
                if (landmarks[8].y < landmarks[6].y) fingersUp++;
                // Middle
                if (landmarks[12].y < landmarks[10].y) fingersUp++;
                // Ring
                if (landmarks[16].y < landmarks[14].y) fingersUp++;
                // Pinky
                if (landmarks[20].y < landmarks[18].y) fingersUp++;
                
                // Thumb (variable based on hand side, simpler check: distance from pinky base)
                // Let's rely on the 4 fingers for Open/Close detection mainly for robustness

                // 3. Detect Pinch (Thumb tip 4 to Index tip 8)
                const dx = landmarks[4].x - landmarks[8].x;
                const dy = landmarks[4].y - landmarks[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // INTERACTION MAPPING
                
                // Transition Logic (Debounced implicitly by animations, but good to check)
                if (dist < 0.05) {
                    // Pinch detected
                    updateState('ZOOM');
                } else if (fingersUp >= 4) {
                    // Open Hand
                    updateState('SCATTERED');
                } else if (fingersUp <= 1) {
                    // Fist
                    updateState('TREE');
                }

                // 4. Rotation Logic (Only in Scattered state usually, but cool in all)
                // Map hand X position to tree rotation speed or absolute rotation
                if (state === 'SCATTERED') {
                    // Map 0.2-0.8 range to rotation
                    const targetRotY = (handX - 0.5) * 4; // -2 to +2 radians
                    const targetRotX = (handY - 0.5) * 2;
                    
                    gsap.to(treeGroup.rotation, {
                        y: targetRotY,
                        x: targetRotX,
                        duration: 1
                    });
                } else if (state === 'TREE') {
                    // Slow idle rotation override
                    treeGroup.rotation.y += 0.005;
                }

            } else {
                isHandPresent = false;
                handCursor.style.display = 'none';
                // Idle animation
                treeGroup.rotation.y += 0.002;
            }
        }

        /**
         * PHOTO UPLOAD HANDLER
         */
        document.getElementById('photo-upload').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files.length) return;

            userPhotos = []; // Clear old or append? Let's clear for fresh look.
            
            let loadedCount = 0;
            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    const tex = new THREE.Texture(img);
                    img.onload = () => { tex.needsUpdate = true; };
                    userPhotos.push(tex);
                    
                    loadedCount++;
                    if (loadedCount === files.length) {
                        // Re-init particles with new photos
                        initParticles();
                        // If we are currently in Tree, re-animate to tree to set positions
                        if (state === 'TREE') animateToTree();
                        else animateToScatter();
                    }
                };
                reader.readAsDataURL(files[i]);
            }
        });

        // Debug Toggle
        let debugMode = false;
        document.getElementById('debug-btn').addEventListener('click', () => {
            debugMode = !debugMode;
            document.getElementById('camera-preview').style.display = debugMode ? 'block' : 'none';
            document.getElementById('debug-btn').innerText = debugMode ? "è°ƒè¯•è§†å›¾: å¼€" : "è°ƒè¯•è§†å›¾: å…³";
        });
        // Default hide debug
        document.getElementById('camera-preview').style.display = 'none';

        /**
         * RENDER LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            // Floating wobble for particles in Scattered mode
            if (state === 'SCATTERED') {
                const time = Date.now() * 0.001;
                objects.forEach((obj, i) => {
                    if (!obj.userData.isPhoto) { // Photos stay relatively stable
                        obj.position.y += Math.sin(time + i) * 0.01;
                    }
                });
            }

            composer.render();
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>