<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Controlled Christmas Tree (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            color: #D4AF37;
            text-align: center;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            pointer-events: auto;
        }

        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 24px; }
        p.subtitle { color: #888; font-size: 12px; margin-top: 5px; }

        .controls {
            pointer-events: auto;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .btn {
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 12px;
            border-radius: 4px;
            pointer-events: auto;
        }

        .btn:hover { background: #D4AF37; color: #000; }

        /* Camera Preview - Always visible for debugging initially */
        #camera-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            background: #000;
            border: 2px solid #333;
            z-index: 20;
            border-radius: 8px;
            overflow: hidden;
            pointer-events: auto;
        }
        
        #camera-preview {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror */
        }

        #gesture-hint {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: white;
            font-size: 14px;
            line-height: 1.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            pointer-events: auto;
        }
        
        .status-line { font-weight: bold; font-size: 16px; margin-bottom: 5px; display: block;}

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #050505;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #D4AF37;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            border-top-color: #D4AF37;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .error-msg {
            color: #ff4d4d;
            margin-top: 10px;
            text-align: center;
            max-width: 80%;
            font-size: 14px;
        }

        /* Cursor */
        #hand-cursor {
            position: absolute;
            width: 30px; height: 30px;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            display: none;
            box-shadow: 0 0 10px #D4AF37;
            transition: width 0.2s, height 0.2s;
        }
        #hand-cursor.pinching {
            background-color: rgba(255, 255, 255, 0.5);
            width: 15px; height: 15px;
        }

        #input-video { display: none; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">æ­£åœ¨åŠ è½½ AI æ¨¡å‹...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
        <div id="error-log" class="error-msg"></div>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <div class="header">
            <h1>Chroma Christmas</h1>
            <p class="subtitle">è¯·ç¡®ä¿åœ¨ HTTPS æˆ– Localhost ç¯å¢ƒè¿è¡Œ</p>
            <div class="controls">
                <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
                <button class="btn" onclick="document.getElementById('photo-upload').click()">+ ä¸Šä¼ ç…§ç‰‡</button>
            </div>
        </div>
        
        <div id="gesture-hint">
            <span class="status-line">å½“å‰çŠ¶æ€: <span id="status-text" style="color:#D4AF37">åˆå§‹åŒ–...</span></span>
            <span id="detected-gesture">æœªæ£€æµ‹åˆ°æ‰‹éƒ¨</span>
            <hr style="border-color: #444; opacity: 0.5;">
            âœŠ <b>æ¡æ‹³</b> - åœ£è¯æ ‘æ€<br>
            ğŸ– <b>å¼ æ‰‹</b> - æ˜Ÿäº‘çˆ†ç‚¸<br>
            ğŸ‘Œ <b>æåˆ</b> - èšç„¦ç…§ç‰‡<br>
        </div>

        <div id="camera-wrapper">
            <canvas id="camera-preview"></canvas>
        </div>
    </div>

    <div id="hand-cursor"></div>
    <!-- Hidden video element for MediaPipe input -->
    <video id="input-video" playsinline style="display:none"></video>
    <div id="canvas-container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- Error Handling Utility ---
        function logError(msg) {
            console.error(msg);
            const el = document.getElementById('error-log');
            el.innerHTML += msg + "<br>";
            document.getElementById('loading-text').style.display = 'none';
            document.querySelector('.spinner').style.borderColor = '#ff4d4d';
        }

        // --- Config ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
        const CONFIG = {
            colors: { green: 0x2F4F4F, gold: 0xFFD700, red: 0x8B0000 },
            particleCount: isMobile ? 200 : 500,
            treeHeight: 25,
            treeRadius: 10,
            scatterRadius: 35
        };

        let state = 'TREE';
        let userPhotos = [];
        
        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 40);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Bloom
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lighting
        scene.add(new THREE.AmbientLight(0x404040, 2));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // --- Objects ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);
        const objects = [];
        const geometries = [
            new THREE.SphereGeometry(0.4, 16, 16),
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.IcosahedronGeometry(0.5, 0)
        ];
        const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.8 });
        const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 1.0 });
        const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, roughness: 0.4 });

        // Placeholder Texture
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#222'; ctx.fillRect(0,0,128,128);
        ctx.strokeStyle = 'gold'; ctx.strokeRect(5,5,118,118);
        const defaultTex = new THREE.CanvasTexture(canvas);

        function initParticles() {
            objects.forEach(o => treeGroup.remove(o));
            objects.length = 0;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                if (Math.random() < 0.15) {
                    // Photo
                    const mat = userPhotos.length > 0 
                        ? new THREE.MeshBasicMaterial({ map: userPhotos[i % userPhotos.length], side: THREE.DoubleSide })
                        : new THREE.MeshBasicMaterial({ map: defaultTex, side: THREE.DoubleSide });
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), mat);
                    mesh.userData.isPhoto = true;
                } else {
                    // Ornament
                    const g = geometries[Math.floor(Math.random() * geometries.length)];
                    const m = Math.random() > 0.6 ? matGold : (Math.random() > 0.3 ? matRed : matGreen);
                    mesh = new THREE.Mesh(g, m);
                }

                // Tree Position (Cone)
                const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const normY = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const r = CONFIG.treeRadius * (1 - normY);
                const angle = y * 3 + Math.random() * Math.PI * 2;
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                // Scatter Position
                mesh.userData.scatterPos = new THREE.Vector3(
                    (Math.random()-0.5)*CONFIG.scatterRadius,
                    (Math.random()-0.5)*CONFIG.scatterRadius,
                    (Math.random()-0.5)*CONFIG.scatterRadius
                );

                mesh.position.copy(mesh.userData.treePos);
                objects.push(mesh);
                treeGroup.add(mesh);
            }
        }
        initParticles();

        // --- Animations ---
        function updateState(newState) {
            if (state === newState) return;
            state = newState;
            
            const statusEl = document.getElementById('status-text');
            if (state === 'TREE') {
                statusEl.innerText = "åœ£è¯æ ‘å½¢æ€ (èšåˆ)";
                statusEl.style.color = "#D4AF37";
                objects.forEach(o => {
                    gsap.to(o.position, { x: o.userData.treePos.x, y: o.userData.treePos.y, z: o.userData.treePos.z, duration: 1.5, ease: "power2.inOut" });
                    gsap.to(o.rotation, { x: Math.random()*Math.PI, y: Math.random()*Math.PI, duration: 1.5 });
                });
            } else if (state === 'SCATTERED') {
                statusEl.innerText = "æ˜Ÿäº‘å½¢æ€ (å‘æ•£)";
                statusEl.style.color = "#ff4d4d";
                objects.forEach(o => {
                    gsap.to(o.position, { x: o.userData.scatterPos.x, y: o.userData.scatterPos.y, z: o.userData.scatterPos.z, duration: 2, ease: "elastic.out(1, 0.75)" });
                });
            } else if (state === 'ZOOM') {
                statusEl.innerText = "ç…§ç‰‡èšç„¦";
                statusEl.style.color = "#fff";
                if (state !== 'SCATTERED') updateState('SCATTERED'); // Ensure background is scattered
                
                const photos = objects.filter(o => o.userData.isPhoto);
                if (photos.length) {
                    const target = photos[Math.floor(Math.random() * photos.length)];
                    gsap.to(target.position, { x: 0, y: 0, z: 25, duration: 1, overwrite: true });
                    gsap.to(target.rotation, { x: 0, y: 0, z: 0, duration: 1 });
                    gsap.to(target.scale, { x: 4, y: 4, z: 4, duration: 1 });
                }
            }
        }

        // --- MediaPipe & Logic ---
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('camera-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const handCursor = document.getElementById('hand-cursor');
        const gestureText = document.getElementById('detected-gesture');

        function onResults(results) {
            // Remove Loader once successful
            const loader = document.getElementById('loader');
            if (loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }

            // Draw Camera Preview
            previewCanvas.width = videoElement.videoWidth || 320;
            previewCanvas.height = videoElement.videoHeight || 240;
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(previewCtx, landmarks, {color: '#FF0000', lineWidth: 1});
                
                // --- Gesture Logic ---
                handCursor.style.display = 'block';
                const x = 1 - landmarks[9].x; // Mirror
                const y = landmarks[9].y;
                handCursor.style.left = (x * 100) + 'vw';
                handCursor.style.top = (y * 100) + 'vh';

                // Count Fingers
                let fingersUp = 0;
                if (landmarks[8].y < landmarks[6].y) fingersUp++; // Index
                if (landmarks[12].y < landmarks[10].y) fingersUp++; // Middle
                if (landmarks[16].y < landmarks[14].y) fingersUp++; // Ring
                if (landmarks[20].y < landmarks[18].y) fingersUp++; // Pinky

                // Pinch Check (Thumb tip 4 & Index tip 8)
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                const isPinching = pinchDist < 0.05;

                if (isPinching) {
                    handCursor.classList.add('pinching');
                    gestureText.innerHTML = "ğŸ‘Œ æ£€æµ‹åˆ°: æåˆ (PINCH)";
                    updateState('ZOOM');
                } else {
                    handCursor.classList.remove('pinching');
                    if (fingersUp >= 4) {
                        gestureText.innerHTML = "ğŸ– æ£€æµ‹åˆ°: å¼ æ‰‹ (OPEN)";
                        updateState('SCATTERED');
                        // Rotation Control in Scattered Mode
                        treeGroup.rotation.y = (x - 0.5) * 4;
                        treeGroup.rotation.x = (y - 0.5) * 2;
                    } else if (fingersUp <= 1) {
                        gestureText.innerHTML = "âœŠ æ£€æµ‹åˆ°: æ¡æ‹³ (FIST)";
                        updateState('TREE');
                    } else {
                        gestureText.innerHTML = "âœ‹ æ‰‹åŠ¿è¿‡æ¸¡ä¸­...";
                    }
                }

            } else {
                handCursor.style.display = 'none';
                gestureText.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
                // Idle Animation
                treeGroup.rotation.y += 0.003;
            }
            previewCtx.restore();
        }

        // Initialize MediaPipe
        async function startCamera() {
            try {
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });
                
                hands.onResults(onResults);

                // Camera Utils
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                
                await cameraUtils.start();
                console.log("Camera started successfully");
                
            } catch (error) {
                logError("åˆå§‹åŒ–å¤±è´¥: " + error.message);
                logError("è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ (æ˜¯å¦èƒ½è®¿é—® cdn.jsdelivr.net?)");
                logError("è¯·ç¡®ä¿ä½¿ç”¨ HTTPS æˆ– Localhost è®¿é—®ã€‚");
            }
        }

        // Check Permissions First
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            startCamera();
        } else {
            logError("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œæˆ–å¤„äºéå®‰å…¨ç¯å¢ƒ(HTTP)ã€‚è¯·ä½¿ç”¨ HTTPS æˆ– localhostã€‚");
        }

        // --- Standard Loops ---
        function animate() {
            requestAnimationFrame(animate);
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Photo Upload
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            if(e.target.files && e.target.files.length > 0) {
                userPhotos = [];
                Array.from(e.target.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => { userPhotos.push(new THREE.CanvasTexture(img)); };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                });
                // Wait a bit then re-init
                setTimeout(() => {
                    initParticles();
                    if(state === 'TREE') updateState('TREE'); // refresh positions
                }, 1000);
            }
        });

    </script>
</body>
</html>